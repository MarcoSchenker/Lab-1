<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test React Development Mode - Socket Stability</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .status {
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            font-weight: bold;
        }
        .status.connected { background-color: #d4edda; color: #155724; }
        .status.connecting { background-color: #fff3cd; color: #856404; }
        .status.error { background-color: #f8d7da; color: #721c24; }
        .logs {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 4px;
            height: 400px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
            white-space: pre-wrap;
            border: 1px solid #dee2e6;
        }
        .controls {
            margin: 20px 0;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }
        .btn-primary { background-color: #007bff; color: white; }
        .btn-success { background-color: #28a745; color: white; }
        .btn-warning { background-color: #ffc107; color: black; }
        .btn-danger { background-color: #dc3545; color: white; }
        .simulation {
            background-color: #e9ecef;
            padding: 15px;
            border-radius: 4px;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üî¨ Test React Development Mode - Simulaci√≥n de Double Effect</h1>
        
        <div class="simulation">
            <h3>üß™ Simulaci√≥n de Comportamiento React Dev Mode</h3>
            <p>Este test simula el comportamiento de React en modo desarrollo donde los useEffect se ejecutan dos veces para detectar efectos secundarios.</p>
            <p><strong>Comportamiento esperado:</strong> El socket debe conectarse solo una vez y mantenerse estable a pesar de m√∫ltiples ejecutuciones del effect.</p>
        </div>
        
        <div id="status" class="status connecting">
            üîÑ Preparando test...
        </div>

        <div class="controls">
            <button id="startSimulationBtn" class="btn-primary">Iniciar Simulaci√≥n React Dev Mode</button>
            <button id="testRoomChangeBtn" class="btn-success">Test Cambio de Sala</button>
            <button id="clearLogsBtn" class="btn-warning">Limpiar Logs</button>
            <button id="resetBtn" class="btn-danger">Reset Completo</button>
        </div>

        <div class="logs" id="logs">
            üìã Simulaci√≥n de React Development Mode iniciar√° aqu√≠...\n
        </div>
    </div>

    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <script>
        class ReactDevModeSimulator {
            constructor() {
                this.socket = null;
                this.currentRoom = null;
                this.isConnecting = false;
                this.isCleaningUp = false;
                this.connectionCount = 0;
                this.disconnectionCount = 0;
                this.effectRunCount = 0;
                
                this.initializeElements();
                this.setupEventListeners();
            }

            initializeElements() {
                this.statusEl = document.getElementById('status');
                this.logsEl = document.getElementById('logs');
            }

            setupEventListeners() {
                document.getElementById('startSimulationBtn').addEventListener('click', () => this.startReactDevModeSimulation());
                document.getElementById('testRoomChangeBtn').addEventListener('click', () => this.testRoomChange());
                document.getElementById('clearLogsBtn').addEventListener('click', () => this.clearLogs());
                document.getElementById('resetBtn').addEventListener('click', () => this.reset());
            }

            log(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                const prefix = type === 'error' ? '‚ùå' : type === 'success' ? '‚úÖ' : type === 'warning' ? '‚ö†Ô∏è' : '‚ÑπÔ∏è';
                const logMessage = `[${timestamp}] ${prefix} ${message}\n`;
                
                this.logsEl.textContent += logMessage;
                this.logsEl.scrollTop = this.logsEl.scrollHeight;
                
                console.log(`[ReactDevModeTest] ${message}`);
            }

            updateStatus(message, type) {
                this.statusEl.textContent = message;
                this.statusEl.className = `status ${type}`;
            }

            // Simula el comportamiento de React.StrictMode en desarrollo
            async startReactDevModeSimulation() {
                this.log('üöÄ Iniciando simulaci√≥n de React Development Mode', 'success');
                this.log('üìñ En React Dev Mode, los useEffect se ejecutan dos veces:', 'info');
                this.log('   1. Mount -> Cleanup -> Mount', 'info');
                this.log('   2. Esto debe ser manejado correctamente por nuestro hook', 'info');
                
                const testRoom = 'dev-mode-test-' + Math.random().toString(36).substr(2, 8);
                
                // Simular primer useEffect (mount)
                this.log('\nüîÑ [SIMULACI√ìN] Primera ejecuci√≥n de useEffect (mount)', 'warning');
                this.effectRunCount++;
                await this.simulateUseEffect(testRoom);
                
                // Simular cleanup inmediato (React Dev Mode)
                this.log('\nüßπ [SIMULACI√ìN] Cleanup inmediato (React Dev Mode)', 'warning');
                await this.simulateCleanup(testRoom);
                
                // Simular segunda ejecuci√≥n de useEffect (re-mount)
                this.log('\nüîÑ [SIMULACI√ìN] Segunda ejecuci√≥n de useEffect (re-mount)', 'warning');
                this.effectRunCount++;
                await this.simulateUseEffect(testRoom);
                
                // Verificar resultado final
                setTimeout(() => {
                    this.verifyStability();
                }, 2000);
            }

            async simulateUseEffect(roomCode) {
                this.log(`[useEffect #${this.effectRunCount}] Ejecutando con codigoSala: ${roomCode}`);
                
                // Simular la l√≥gica del hook optimizado
                if (roomCode && this.currentRoom === roomCode && this.socket?.connected) {
                    this.log('[useEffect] ‚úÖ Ya conectado a esta sala, saltando reconexi√≥n', 'success');
                    return;
                }
                
                this.currentRoom = roomCode;
                
                if (roomCode && !this.isCleaningUp) {
                    this.log(`[useEffect] üöÄ Iniciando conexi√≥n para sala: ${roomCode}`);
                    await this.connectSocket(roomCode);
                } else {
                    this.log('[useEffect] ‚è≠Ô∏è Saltando conexi√≥n (cleanup en progreso)', 'warning');
                }
            }

            async simulateCleanup(roomCode) {
                this.log(`[Cleanup] üßπ Cleanup del hook para sala: ${roomCode}`);
                
                // Simular la l√≥gica del cleanup optimizado
                const isRoomChange = this.currentRoom !== roomCode;
                const shouldCleanup = isRoomChange || !roomCode;
                
                if (shouldCleanup) {
                    this.log('[Cleanup] üîÑ Ejecutando cleanup completo', 'warning');
                    this.isCleaningUp = true;
                    
                    if (this.socket) {
                        this.log('[Cleanup] üîå Desconectando socket');
                        this.socket.disconnect();
                        this.socket = null;
                        this.disconnectionCount++;
                    }
                    
                    this.isConnecting = false;
                    this.currentRoom = null;
                    
                    // Reset cleanup flag despu√©s de un delay
                    setTimeout(() => {
                        this.isCleaningUp = false;
                        this.log('[Cleanup] ‚úÖ Cleanup flag reseteado');
                    }, 100);
                } else {
                    this.log('[Cleanup] ‚è≠Ô∏è Saltando cleanup - misma sala', 'success');
                }
            }

            async connectSocket(roomCode) {
                this.log(`[connectSocket] üîç Debug connectSocket llamado con codigoSala: ${roomCode}`);
                
                if (!roomCode) {
                    this.log('[connectSocket] ‚ùå C√≥digo de sala no proporcionado', 'error');
                    return;
                }
                
                // Evitar m√∫ltiples conexiones simult√°neas
                if (this.isConnecting) {
                    this.log('[connectSocket] üîÑ Conexi√≥n ya en progreso, ignorando nueva solicitud', 'warning');
                    return;
                }
                
                // Evitar reconexi√≥n durante cleanup
                if (this.isCleaningUp) {
                    this.log('[connectSocket] üßπ Cleanup en progreso, ignorando conexi√≥n', 'warning');
                    return;
                }

                if (this.socket && this.socket.connected) {
                    this.log('[connectSocket] ‚úÖ Socket ya conectado, verificando sala actual');
                    // Si estamos conectados a la misma sala, no reconectar
                    if (this.currentRoom === roomCode) {
                        this.log('[connectSocket] ‚úÖ Ya conectado a la sala correcta', 'success');
                        return;
                    }
                }

                this.isConnecting = true;
                this.log(`[connectSocket] üîå Conectando a sala ${roomCode}...`);
                this.updateStatus(`üîå Conectando a ${roomCode}...`, 'connecting');

                // Simular autenticaci√≥n
                const mockToken = 'mock-token-' + Math.random().toString(36).substr(2, 8);

                // Desconectar socket existente si est√° conectado a otra sala
                if (this.socket && this.currentRoom !== roomCode) {
                    this.log(`[connectSocket] üîÑ Desconectando de sala anterior: ${this.currentRoom}`);
                    this.socket.disconnect();
                    this.socket = null;
                    this.disconnectionCount++;
                }

                // Crear nueva conexi√≥n
                this.socket = io('http://localhost:3001', {
                    query: { 
                        codigoSala: roomCode,
                        token: mockToken,
                        anonymous: false 
                    },
                    transports: ['websocket', 'polling'],
                    reconnectionAttempts: 5,
                    reconnectionDelay: 1000,
                    autoConnect: false,
                    forceNew: true
                });

                this.currentRoom = roomCode;
                this.setupSocketEvents();
                this.socket.connect();
            }

            setupSocketEvents() {
                if (!this.socket) return;

                this.socket.on('connect', () => {
                    this.connectionCount++;
                    this.isConnecting = false;
                    this.log(`‚úÖ Socket conectado: ${this.socket.id}`, 'success');
                    this.updateStatus('‚úÖ Conectado', 'connected');
                    
                    // Autenticar
                    const mockToken = 'mock-token';
                    this.socket.emit('autenticar_socket', mockToken);
                });

                this.socket.on('disconnect', (reason) => {
                    this.log(`üîå Socket desconectado: ${reason}`, 'warning');
                    this.updateStatus('üîå Desconectado', 'error');
                });

                this.socket.on('autenticacion_exitosa', (data) => {
                    this.log(`‚úÖ Autenticaci√≥n exitosa`, 'success');
                });

                this.socket.on('connect_error', (error) => {
                    this.log(`‚ùå Error de conexi√≥n: ${error.message}`, 'error');
                    this.updateStatus('‚ùå Error de conexi√≥n', 'error');
                    this.isConnecting = false;
                });
            }

            async testRoomChange() {
                this.log('\nüîÑ Iniciando test de cambio de sala...', 'success');
                
                const room1 = 'room-1-' + Math.random().toString(36).substr(2, 4);
                const room2 = 'room-2-' + Math.random().toString(36).substr(2, 4);
                
                // Conectar a primera sala
                this.log(`üì° Conectando a primera sala: ${room1}`);
                await this.simulateUseEffect(room1);
                
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                // Simular cleanup para cambio de sala
                this.log(`üîÑ Cambiando a segunda sala: ${room2}`);
                await this.simulateCleanup(room1);
                
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Conectar a segunda sala
                await this.simulateUseEffect(room2);
                
                setTimeout(() => {
                    this.log('üèÅ Test de cambio de sala completado', 'success');
                    this.verifyStability();
                }, 1000);
            }

            verifyStability() {
                this.log('\nüìä REPORTE DE ESTABILIDAD:', 'success');
                this.log(`   üîå Conexiones totales: ${this.connectionCount}`);
                this.log(`   ‚ùå Desconexiones totales: ${this.disconnectionCount}`);
                this.log(`   üîÑ useEffect ejecutados: ${this.effectRunCount}`);
                this.log(`   üì° Socket actual: ${this.socket?.connected ? 'Conectado' : 'Desconectado'}`);
                this.log(`   üè† Sala actual: ${this.currentRoom || 'Ninguna'}`);
                
                const isStable = this.socket?.connected && this.connectionCount === 1;
                
                if (isStable) {
                    this.log('üéâ RESULTADO: ESTABLE ‚úÖ', 'success');
                    this.log('   El hook maneja correctamente React Dev Mode', 'success');
                    this.updateStatus('üéâ Test EXITOSO - Socket Estable', 'connected');
                } else {
                    this.log('‚ö†Ô∏è RESULTADO: INESTABLE ‚ùå', 'error');
                    this.log('   El hook necesita m√°s optimizaci√≥n', 'error');
                    this.updateStatus('‚ö†Ô∏è Test FALLIDO - Socket Inestable', 'error');
                }
            }

            clearLogs() {
                this.logsEl.textContent = 'üìã Logs limpiados...\n';
            }

            reset() {
                if (this.socket) {
                    this.socket.disconnect();
                    this.socket = null;
                }
                
                this.currentRoom = null;
                this.isConnecting = false;
                this.isCleaningUp = false;
                this.connectionCount = 0;
                this.disconnectionCount = 0;
                this.effectRunCount = 0;
                
                this.updateStatus('üîÑ Reset completo', 'connecting');
                this.clearLogs();
                this.log('üîÑ Sistema reseteado completamente', 'success');
            }
        }

        // Inicializar simulador cuando la p√°gina carga
        document.addEventListener('DOMContentLoaded', () => {
            new ReactDevModeSimulator();
        });
    </script>
</body>
</html>
