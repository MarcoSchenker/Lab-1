<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üöÄ Performance Monitoring Test - Truco Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: white;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .metric-card {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
        }
        
        .metric-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
        }
        
        .metric-card h3 {
            margin-bottom: 15px;
            color: #4ecdc4;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .metric-value {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .metric-label {
            font-size: 0.9rem;
            opacity: 0.8;
        }
        
        .controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 30px;
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
        }
        
        .btn-primary {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            color: white;
        }
        
        .btn-success {
            background: linear-gradient(45deg, #56ab2f, #a8e6cf);
            color: white;
        }
        
        .btn-warning {
            background: linear-gradient(45deg, #f093fb, #f5576c);
            color: white;
        }
        
        .btn-info {
            background: linear-gradient(45deg, #4facfe, #00f2fe);
            color: white;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        }
        
        .log-container {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            max-height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
        }
        
        .log-entry {
            margin-bottom: 8px;
            padding: 5px;
            border-radius: 4px;
        }
        
        .log-info { background: rgba(52, 152, 219, 0.2); }
        .log-success { background: rgba(46, 204, 113, 0.2); }
        .log-warning { background: rgba(241, 196, 15, 0.2); }
        .log-error { background: rgba(231, 76, 60, 0.2); }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 10px;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4ecdc4, #44a08d);
            transition: width 0.3s ease;
        }
        
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .status-online { background: #2ecc71; }
        .status-warning { background: #f39c12; }
        .status-error { background: #e74c3c; }
        
        .performance-chart {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            text-align: center;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.js"></script>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üöÄ Game Performance Monitor</h1>
            <p>Real-time performance tracking and optimization testing</p>
        </div>

        <div class="status-grid">
            <div class="metric-card">
                <h3><span class="status-indicator status-online"></span>Connection Status</h3>
                <div class="metric-value" id="connectionStatus">Connecting...</div>
                <div class="metric-label">Socket connection state</div>
            </div>

            <div class="metric-card">
                <h3>‚ö° Connection Time</h3>
                <div class="metric-value" id="connectionTime">-</div>
                <div class="metric-label">Initial connection latency</div>
            </div>

            <div class="metric-card">
                <h3>üìä State Updates</h3>
                <div class="metric-value" id="stateUpdates">0</div>
                <div class="metric-label">Game states received</div>
            </div>

            <div class="metric-card">
                <h3>üíæ Cache Performance</h3>
                <div class="metric-value" id="cacheHits">0</div>
                <div class="metric-label">Server + localStorage hits</div>
            </div>

            <div class="metric-card">
                <h3>üîÑ Recovery Attempts</h3>
                <div class="metric-value" id="recoveryAttempts">0</div>
                <div class="metric-label">Automatic recovery triggers</div>
            </div>

            <div class="metric-card">
                <h3>‚ö†Ô∏è Network Errors</h3>
                <div class="metric-value" id="networkErrors">0</div>
                <div class="metric-label">Connection issues detected</div>
            </div>

            <div class="metric-card">
                <h3>üìà Average Latency</h3>
                <div class="metric-value" id="averageLatency">-</div>
                <div class="metric-label">Response time average</div>
            </div>

            <div class="metric-card">
                <h3>‚è±Ô∏è Session Duration</h3>
                <div class="metric-value" id="sessionDuration">0m</div>
                <div class="metric-label">Current session length</div>
            </div>
        </div>

        <div class="controls">
            <button class="btn btn-primary" onclick="startPerformanceTest()">
                üß™ Start Performance Test
            </button>
            <button class="btn btn-success" onclick="simulateLoadingScenarios()">
                ‚ö° Simulate Loading Tests
            </button>
            <button class="btn btn-warning" onclick="testCacheEfficiency()">
                üíæ Test Cache System
            </button>
            <button class="btn btn-info" onclick="exportMetrics()">
                üìä Export Metrics
            </button>
            <button class="btn btn-warning" onclick="clearLogs()">
                üóëÔ∏è Clear Logs
            </button>
        </div>

        <div class="performance-chart">
            <h3>üéØ Performance Score</h3>
            <div class="metric-value" id="performanceScore">Calculating...</div>
            <div class="progress-bar">
                <div class="progress-fill" id="performanceProgress" style="width: 0%"></div>
            </div>
        </div>

        <div class="log-container" id="logContainer">
            <div class="log-entry log-info">üöÄ Performance monitoring initialized...</div>
        </div>
    </div>

    <script>
        // Performance Monitor Implementation
        class GamePerformanceMonitor {
            constructor() {
                this.metrics = {
                    sessionId: `session_${Date.now()}`,
                    startTime: Date.now(),
                    connectionTime: null,
                    stateUpdates: 0,
                    cacheHits: 0,
                    localStorageHits: 0,
                    recoveryAttempts: 0,
                    networkErrors: 0,
                    latencyMeasurements: [],
                    averageLatency: 0
                };
                this.isEnabled = true;
                this.lastLogTime = Date.now();
            }

            trackConnectionTime(duration) {
                this.metrics.connectionTime = duration;
                this.log(`üîó Connection established in ${duration}ms`, 'success');
                this.updateUI();
            }

            trackStateReceived(latency = null) {
                this.metrics.stateUpdates++;
                if (latency) {
                    this.metrics.latencyMeasurements.push(latency);
                    this.updateAverageLatency();
                }
                this.log(`üìä State received (${this.metrics.stateUpdates})`, 'info');
                this.updateUI();
            }

            trackCacheHit(source) {
                if (source === 'localStorage') {
                    this.metrics.localStorageHits++;
                } else {
                    this.metrics.cacheHits++;
                }
                this.log(`üíæ Cache hit from ${source}`, 'success');
                this.updateUI();
            }

            trackRecoveryAttempt(reason) {
                this.metrics.recoveryAttempts++;
                this.log(`üîÑ Recovery attempt: ${reason}`, 'warning');
                this.updateUI();
            }

            trackNetworkError(error) {
                this.metrics.networkErrors++;
                this.log(`‚ùå Network error: ${error}`, 'error');
                this.updateUI();
            }

            updateAverageLatency() {
                const measurements = this.metrics.latencyMeasurements;
                if (measurements.length > 0) {
                    const sum = measurements.reduce((a, b) => a + b, 0);
                    this.metrics.averageLatency = sum / measurements.length;
                    // Keep only last 50 measurements
                    if (measurements.length > 50) {
                        this.metrics.latencyMeasurements = measurements.slice(-50);
                    }
                }
            }

            calculatePerformanceScore() {
                let score = 100;
                
                // Connection time penalty
                if (this.metrics.connectionTime > 2000) score -= 20;
                else if (this.metrics.connectionTime > 1000) score -= 10;
                
                // Average latency penalty
                if (this.metrics.averageLatency > 500) score -= 20;
                else if (this.metrics.averageLatency > 200) score -= 10;
                
                // Network errors penalty
                score -= (this.metrics.networkErrors * 5);
                
                // Recovery attempts penalty
                score -= (this.metrics.recoveryAttempts * 3);
                
                // Cache efficiency bonus
                const totalRequests = this.metrics.stateUpdates;
                const cacheTotal = this.metrics.cacheHits + this.metrics.localStorageHits;
                if (totalRequests > 0) {
                    const cacheRate = (cacheTotal / totalRequests) * 100;
                    if (cacheRate > 50) score += 10;
                }
                
                return Math.max(0, Math.min(100, score));
            }

            log(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                const logContainer = document.getElementById('logContainer');
                const logEntry = document.createElement('div');
                logEntry.className = `log-entry log-${type}`;
                logEntry.innerHTML = `[${timestamp}] ${message}`;
                logContainer.appendChild(logEntry);
                logContainer.scrollTop = logContainer.scrollHeight;
                
                console.log(`[Performance] ${message}`);
            }

            updateUI() {
                // Update metric displays
                document.getElementById('connectionTime').textContent = 
                    this.metrics.connectionTime ? `${this.metrics.connectionTime}ms` : '-';
                document.getElementById('stateUpdates').textContent = this.metrics.stateUpdates;
                document.getElementById('cacheHits').textContent = 
                    this.metrics.cacheHits + this.metrics.localStorageHits;
                document.getElementById('recoveryAttempts').textContent = this.metrics.recoveryAttempts;
                document.getElementById('networkErrors').textContent = this.metrics.networkErrors;
                document.getElementById('averageLatency').textContent = 
                    this.metrics.averageLatency ? `${Math.round(this.metrics.averageLatency)}ms` : '-';
                
                // Update session duration
                const duration = Math.round((Date.now() - this.metrics.startTime) / 60000);
                document.getElementById('sessionDuration').textContent = `${duration}m`;
                
                // Update performance score
                const score = this.calculatePerformanceScore();
                document.getElementById('performanceScore').textContent = `${Math.round(score)}/100`;
                document.getElementById('performanceProgress').style.width = `${score}%`;
            }

            exportMetrics() {
                const report = {
                    session: this.metrics,
                    timestamp: new Date().toISOString(),
                    performanceScore: this.calculatePerformanceScore()
                };
                
                const blob = new Blob([JSON.stringify(report, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `performance-metrics-${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
                
                this.log('üìä Metrics exported successfully', 'success');
            }
        }

        // Initialize performance monitor
        const performanceMonitor = new GamePerformanceMonitor();
        let socket = null;
        let testToken = null;

        // Create test token
        function createTestToken() {
            const header = btoa(JSON.stringify({typ: "JWT", alg: "HS256"}));
            const payload = btoa(JSON.stringify({id: 999, exp: Date.now() + 3600000}));
            const signature = btoa("test-signature");
            return `${header}.${payload}.${signature}`;
        }

        // Performance test functions
        function startPerformanceTest() {
            performanceMonitor.log('üß™ Starting comprehensive performance test...', 'info');
            
            if (!testToken) {
                testToken = createTestToken();
            }

            // Test 1: Connection time
            const connectionStart = Date.now();
            socket = io('http://localhost:3001', {
                auth: { token: testToken },
                transports: ['websocket', 'polling'],
                timeout: 20000
            });

            socket.on('connect', () => {
                const connectionTime = Date.now() - connectionStart;
                performanceMonitor.trackConnectionTime(connectionTime);
                document.getElementById('connectionStatus').textContent = 'Connected ‚úÖ';
                
                // Test state requests
                setTimeout(() => testStateRequests(), 1000);
            });

            socket.on('connect_error', (error) => {
                performanceMonitor.trackNetworkError('connection_failed');
                document.getElementById('connectionStatus').textContent = 'Failed ‚ùå';
            });

            socket.on('disconnect', () => {
                document.getElementById('connectionStatus').textContent = 'Disconnected ‚ö†Ô∏è';
                performanceMonitor.trackNetworkError('disconnection');
            });
        }

        function testStateRequests() {
            performanceMonitor.log('üìä Testing state request performance...', 'info');
            
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    const requestStart = Date.now();
                    
                    // Simulate state reception
                    setTimeout(() => {
                        const latency = Date.now() - requestStart;
                        performanceMonitor.trackStateReceived(latency);
                    }, Math.random() * 200 + 50); // 50-250ms simulated latency
                    
                }, i * 1000);
            }
        }

        function simulateLoadingScenarios() {
            performanceMonitor.log('‚ö° Simulating various loading scenarios...', 'warning');
            
            // Scenario 1: Fast connection
            setTimeout(() => {
                performanceMonitor.trackConnectionTime(150);
                performanceMonitor.trackStateReceived(80);
            }, 500);
            
            // Scenario 2: Cache hit
            setTimeout(() => {
                performanceMonitor.trackCacheHit('localStorage');
                performanceMonitor.trackStateReceived(25); // Fast from cache
            }, 1500);
            
            // Scenario 3: Network issue + recovery
            setTimeout(() => {
                performanceMonitor.trackNetworkError('timeout');
                performanceMonitor.trackRecoveryAttempt('auto_reconnect');
                performanceMonitor.trackCacheHit('localStorage'); // Fallback to cache
            }, 2500);
            
            // Scenario 4: Server cache hit
            setTimeout(() => {
                performanceMonitor.trackCacheHit('server');
                performanceMonitor.trackStateReceived(120);
            }, 3500);
        }

        function testCacheEfficiency() {
            performanceMonitor.log('üíæ Testing cache system efficiency...', 'info');
            
            // Simulate multiple cache hits
            for (let i = 0; i < 10; i++) {
                setTimeout(() => {
                    const source = Math.random() > 0.5 ? 'server' : 'localStorage';
                    performanceMonitor.trackCacheHit(source);
                    
                    // Faster response from cache
                    const cacheLatency = source === 'localStorage' ? 15 : 45;
                    performanceMonitor.trackStateReceived(cacheLatency);
                }, i * 300);
            }
        }

        function exportMetrics() {
            performanceMonitor.exportMetrics();
        }

        function clearLogs() {
            document.getElementById('logContainer').innerHTML = 
                '<div class="log-entry log-info">üßπ Logs cleared</div>';
        }

        // Auto-update UI every 2 seconds
        setInterval(() => {
            performanceMonitor.updateUI();
        }, 2000);

        // Initialize UI
        performanceMonitor.updateUI();
        performanceMonitor.log('üéØ Performance monitor ready for testing', 'success');
    </script>
</body>
</html>
