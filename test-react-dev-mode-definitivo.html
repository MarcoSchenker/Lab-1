<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Definitivo - React Dev Mode</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }
        .container { max-width: 1000px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .status-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin: 20px 0; }
        .status-card { padding: 15px; border-radius: 6px; text-align: center; font-weight: bold; }
        .connected { background: #d4edda; color: #155724; border: 2px solid #c3e6cb; }
        .disconnected { background: #f8d7da; color: #721c24; border: 2px solid #f5c6cb; }
        .loading { background: #fff3cd; color: #856404; border: 2px solid #ffeaa7; }
        .log { margin: 2px 0; padding: 6px 10px; border-radius: 4px; font-family: 'Courier New', monospace; font-size: 11px; }
        .log-success { background: #d4edda; color: #155724; }
        .log-error { background: #f8d7da; color: #721c24; }
        .log-info { background: #d1ecf1; color: #0c5460; }
        .log-warning { background: #fff3cd; color: #856404; }
        .buttons { margin: 20px 0; }
        .btn { padding: 10px 20px; margin: 5px; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: bold; }
        .btn-primary { background: #007bff; color: white; }
        .btn-success { background: #28a745; color: white; }
        .btn-danger { background: #dc3545; color: white; }
        .btn-warning { background: #ffc107; color: #212529; }
        .btn-secondary { background: #6c757d; color: white; }
        .logs-container { max-height: 400px; overflow-y: auto; border: 1px solid #ddd; padding: 15px; background: #f8f9fa; border-radius: 4px; }
        .test-results { margin: 20px 0; padding: 15px; border-radius: 4px; }
        .test-pass { background: #d4edda; color: #155724; border: 2px solid #c3e6cb; }
        .test-fail { background: #f8d7da; color: #721c24; border: 2px solid #f5c6cb; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üî• Test Definitivo - React Dev Mode Socket Fix</h1>
        
        <div class="status-grid">
            <div id="socket1-status" class="status-card disconnected">
                üî¥ Socket 1: Desconectado
            </div>
            <div id="socket2-status" class="status-card disconnected">
                üî¥ Socket 2: Desconectado
            </div>
            <div id="cleanup-status" class="status-card loading">
                ‚è≥ Cleanup: Pendiente
            </div>
            <div id="test-status" class="status-card loading">
                ‚è≥ Test: No iniciado
            </div>
        </div>
        
        <div class="buttons">
            <button class="btn btn-primary" onclick="runFullTest()">üß™ Test Completo React Dev Mode</button>
            <button class="btn btn-success" onclick="testNormalConnection()">‚úÖ Test Conexi√≥n Normal</button>
            <button class="btn btn-warning" onclick="testMultipleCleanups()">‚ö° Test M√∫ltiples Cleanups</button>
            <button class="btn btn-danger" onclick="forceDisconnect()">‚ùå Forzar Desconexi√≥n</button>
            <button class="btn btn-secondary" onclick="clearLogs()">üßπ Limpiar</button>
        </div>
        
        <div id="test-results" class="test-results" style="display: none;"></div>
        
        <h3>üìã Logs de Prueba</h3>
        <div id="logs" class="logs-container"></div>
    </div>
    
    <script src="/socket.io/socket.io.js"></script>
    <script>
        const SERVER_URL = 'http://localhost:3001';
        let socket1 = null, socket2 = null;
        let testStartTime = 0;
        let cleanupCount = 0;
        let lastCleanupTime = 0;
        
        // Simular las variables globales del hook
        let reactDevModeCleanupCount = 0;
        let lastGlobalCleanupTime = 0;
        
        function log(message, type = 'info') {
            const div = document.createElement('div');
            div.className = `log log-${type}`;
            div.innerHTML = `<strong>[${new Date().toLocaleTimeString().split(' ')[0]}]</strong> ${message}`;
            document.getElementById('logs').appendChild(div);
            document.getElementById('logs').scrollTop = document.getElementById('logs').scrollHeight;
            console.log(`[${type.toUpperCase()}] ${message}`);
        }
        
        function clearLogs() {
            document.getElementById('logs').innerHTML = '';
            document.getElementById('test-results').style.display = 'none';
        }
        
        function updateStatus(socketNum, status) {
            const element = document.getElementById(`socket${socketNum}-status`);
            if (status === 'connected') {
                element.textContent = `üü¢ Socket ${socketNum}: Conectado`;
                element.className = 'status-card connected';
            } else if (status === 'connecting') {
                element.textContent = `üîÑ Socket ${socketNum}: Conectando...`;
                element.className = 'status-card loading';
            } else {
                element.textContent = `üî¥ Socket ${socketNum}: Desconectado`;
                element.className = 'status-card disconnected';
            }
        }
        
        function updateCleanupStatus(status, count = cleanupCount) {
            const element = document.getElementById('cleanup-status');
            element.textContent = `üßπ Cleanups: ${count} (${status})`;
            element.className = `status-card ${status === 'activo' ? 'loading' : 'connected'}`;
        }
        
        function updateTestStatus(status, result = '') {
            const element = document.getElementById('test-status');
            const resultElement = document.getElementById('test-results');
            
            if (status === 'running') {
                element.textContent = 'üîÑ Test: Ejecutando...';
                element.className = 'status-card loading';
            } else if (status === 'pass') {
                element.textContent = '‚úÖ Test: √âXITO';
                element.className = 'status-card connected';
                resultElement.innerHTML = `<h4>‚úÖ TEST EXITOSO</h4><p>${result}</p>`;
                resultElement.className = 'test-results test-pass';
                resultElement.style.display = 'block';
            } else if (status === 'fail') {
                element.textContent = '‚ùå Test: FALL√ì';
                element.className = 'status-card disconnected';
                resultElement.innerHTML = `<h4>‚ùå TEST FALLIDO</h4><p>${result}</p>`;
                resultElement.className = 'test-results test-fail';
                resultElement.style.display = 'block';
            }
        }
        
        function createSocket(socketNum, room, onConnect, onDisconnect) {
            log(`üîå Creando socket ${socketNum} para sala: ${room}`, 'info');
            updateStatus(socketNum, 'connecting');
            
            const socket = io(SERVER_URL, {
                query: { 
                    codigoSala: room, 
                    token: `test-token-${socketNum}-${Date.now()}`,
                    anonymous: false 
                },
                transports: ['websocket', 'polling'],
                autoConnect: false,
                forceNew: true
            });
            
            const startTime = Date.now();
            socket.connectedAt = startTime;
            
            socket.on('connect', () => {
                log(`‚úÖ Socket ${socketNum} conectado: ${socket.id}`, 'success');
                socket.connectedAt = Date.now(); // Actualizar timestamp real
                updateStatus(socketNum, 'connected');
                if (onConnect) onConnect(socket);
            });
            
            socket.on('disconnect', (reason) => {
                log(`‚ùå Socket ${socketNum} desconectado: ${reason}`, 'error');
                updateStatus(socketNum, 'disconnected');
                if (onDisconnect) onDisconnect(socket, reason);
            });
            
            socket.on('error', (error) => {
                log(`‚ùå Socket ${socketNum} error: ${error}`, 'error');
            });
            
            socket.connect();
            return socket;
        }
        
        function simulateCleanup(socket, socketNum, codigoSala) {
            const now = Date.now();
            const isReactDevMode = true; // Simular dev mode
            const connectionAge = socket && socket.connectedAt ? now - socket.connectedAt : 0;
            const timeSinceLastCleanup = now - lastGlobalCleanupTime;
            
            log(`üßπ Simulando cleanup para socket ${socketNum}`, 'warning');
            log(`üîç Cleanup check: age=${connectionAge}ms, timeSinceLastCleanup=${timeSinceLastCleanup}ms, cleanupCount=${reactDevModeCleanupCount}`, 'info');
            
            cleanupCount++;
            updateCleanupStatus('activo', cleanupCount);
            
            // Aplicar la l√≥gica del hook mejorado
            if (isReactDevMode && timeSinceLastCleanup < 1000) {
                reactDevModeCleanupCount++;
                log(`üîÑ M√∫ltiples cleanups detectados en Dev Mode, count: ${reactDevModeCleanupCount}`, 'warning');
                
                // Si es el primer cleanup r√°pido y tenemos conexi√≥n activa, no hacer nada
                if (reactDevModeCleanupCount === 1 && socket && socket.connected) {
                    log(`üîÑ Primer cleanup r√°pido ignorado, manteniendo conexi√≥n socket ${socketNum}`, 'success');
                    lastGlobalCleanupTime = now;
                    return false; // No cleanup
                }
            } else {
                // Reset counter si ha pasado suficiente tiempo
                reactDevModeCleanupCount = 0;
            }
            
            lastGlobalCleanupTime = now;
            
            // Ejecutar cleanup
            log(`üíÄ Ejecutando cleanup completo para socket ${socketNum}`, 'error');
            if (socket && socket.connected) {
                socket.disconnect();
            }
            
            updateCleanupStatus('completo', cleanupCount);
            return true; // Cleanup ejecutado
        }
        
        function runFullTest() {
            log('üöÄ Iniciando test completo de React Dev Mode...', 'info');
            updateTestStatus('running');
            testStartTime = Date.now();
            cleanupCount = 0;
            reactDevModeCleanupCount = 0;
            lastGlobalCleanupTime = 0;
            
            const testRoom = `test-dev-mode-${Date.now()}`;
            let socket1Connected = false;
            let socket1Disconnected = false;
            let cleanupResults = [];
            
            // Paso 1: Crear primer socket (mount)
            log('üìç PASO 1: Creando primer socket (mount)', 'info');
            socket1 = createSocket(1, testRoom, 
                (socket) => {
                    socket1Connected = true;
                    log('‚úÖ Socket1 conectado exitosamente', 'success');
                    
                    // Paso 2: Simular cleanup inmediato (React Dev Mode)
                    setTimeout(() => {
                        log('üìç PASO 2: Simulando cleanup inmediato (React Dev Mode)', 'warning');
                        const cleanupExecuted = simulateCleanup(socket1, 1, testRoom);
                        cleanupResults.push({ step: 'immediate_cleanup', executed: cleanupExecuted });
                        
                        if (cleanupExecuted) {
                            socket1Disconnected = true;
                        }
                        
                        // Paso 3: Crear segundo socket (remount)
                        setTimeout(() => {
                            log('üìç PASO 3: Creando segundo socket (remount)', 'info');
                            socket2 = createSocket(2, testRoom,
                                (socket) => {
                                    log('‚úÖ Socket2 conectado exitosamente', 'success');
                                    
                                    // Evaluar resultado del test
                                    setTimeout(() => {
                                        evaluateTestResults(cleanupResults, socket1Connected, socket1Disconnected);
                                    }, 1000);
                                },
                                (socket, reason) => {
                                    log(`‚ùå Socket2 desconectado inesperadamente: ${reason}`, 'error');
                                }
                            );
                        }, 100);
                        
                    }, 150); // Cleanup muy r√°pido despu√©s de conexi√≥n
                },
                (socket, reason) => {
                    socket1Disconnected = true;
                    log(`Socket1 desconectado: ${reason}`, socket1Connected ? 'warning' : 'error');
                }
            );
        }
        
        function evaluateTestResults(cleanupResults, socket1Connected, socket1Disconnected) {
            log('üîç Evaluando resultados del test...', 'info');
            
            const testDuration = Date.now() - testStartTime;
            log(`‚è±Ô∏è Duraci√≥n del test: ${testDuration}ms`, 'info');
            
            // Verificar condiciones de √©xito
            const socket1StillConnected = socket1 && socket1.connected;
            const socket2Connected = socket2 && socket2.connected;
            const immediateCleanupPrevented = cleanupResults.some(r => r.step === 'immediate_cleanup' && !r.executed);
            
            log(`üìä Resultados:`, 'info');
            log(`  - Socket1 conect√≥: ${socket1Connected}`, socket1Connected ? 'success' : 'error');
            log(`  - Socket1 a√∫n conectado: ${socket1StillConnected}`, socket1StillConnected ? 'success' : 'error');
            log(`  - Socket2 conectado: ${socket2Connected}`, socket2Connected ? 'success' : 'error');
            log(`  - Cleanup inmediato prevenido: ${immediateCleanupPrevented}`, immediateCleanupPrevented ? 'success' : 'error');
            log(`  - Total cleanups: ${cleanupCount}`, 'info');
            log(`  - React Dev Mode cleanups: ${reactDevModeCleanupCount}`, 'info');
            
            // Determinar √©xito del test
            const testPassed = socket1Connected && socket1StillConnected && immediateCleanupPrevented;
            
            if (testPassed) {
                updateTestStatus('pass', 'El socket sobrevivi√≥ al cleanup inmediato de React Dev Mode. La implementaci√≥n funciona correctamente.');
                log('üéâ TEST EXITOSO: La soluci√≥n React Dev Mode funciona!', 'success');
            } else {
                updateTestStatus('fail', 'El socket no sobrevivi√≥ al cleanup inmediato. La implementaci√≥n necesita ajustes.');
                log('üí• TEST FALLIDO: La soluci√≥n necesita mejoras', 'error');
            }
            
            // Limpiar sockets despu√©s del test
            setTimeout(() => {
                if (socket1) socket1.disconnect();
                if (socket2) socket2.disconnect();
                socket1 = null;
                socket2 = null;
                updateStatus(1, 'disconnected');
                updateStatus(2, 'disconnected');
            }, 3000);
        }
        
        function testNormalConnection() {
            log('üîå Test de conexi√≥n normal...', 'info');
            const room = `normal-test-${Date.now()}`;
            socket1 = createSocket(1, room, 
                (socket) => log('‚úÖ Conexi√≥n normal exitosa', 'success'),
                (socket, reason) => log(`‚ùå Conexi√≥n normal fall√≥: ${reason}`, 'error')
            );
        }
        
        function testMultipleCleanups() {
            log('‚ö° Test de m√∫ltiples cleanups r√°pidos...', 'warning');
            
            for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                    log(`Cleanup simulado #${i + 1}`, 'warning');
                    if (socket1) {
                        simulateCleanup(socket1, 1, 'test-room');
                    }
                }, i * 50);
            }
        }
        
        function forceDisconnect() {
            log('‚ùå Forzando desconexi√≥n de todos los sockets...', 'error');
            if (socket1) {
                socket1.disconnect();
                socket1 = null;
                updateStatus(1, 'disconnected');
            }
            if (socket2) {
                socket2.disconnect();
                socket2 = null;
                updateStatus(2, 'disconnected');
            }
            cleanupCount = 0;
            reactDevModeCleanupCount = 0;
            updateCleanupStatus('reset', 0);
        }
        
        // Inicializaci√≥n
        log('üîß Test de React Dev Mode listo. Ejecuta "Test Completo" para probar la soluci√≥n.', 'info');
        updateStatus(1, 'disconnected');
        updateStatus(2, 'disconnected');
        updateCleanupStatus('inactivo', 0);
    </script>
</body>
</html>
